// Behavior Tree implementation for volleyball AI
// Refactored to be pure - nodes return results instead of mutating state

import type {
  Blackboard,
  GoalType,
  PlayerState,
  RequestedGoal,
  ThoughtMessage,
} from "@/lib/sim/types";
import type { Intent } from "@/lib/sim/intent";
import { createGoalIntent } from "@/lib/sim/intent";
import type { BTNodeTrace, BTNodeType } from "@/lib/sim/trace";

export type BTStatus = "SUCCESS" | "FAILURE" | "RUNNING";

/**
 * Result of a BT node evaluation (pure - no side effects)
 */
export type BTResult = {
  status: BTStatus;
  /** Intents generated by this node and its children */
  intents: Intent[];
  /** Trace of the evaluation for explainability */
  trace: BTNodeTrace;
};

/**
 * Context provided to BT nodes for evaluation (read-only)
 */
export type BTContext = {
  blackboard: Blackboard;
  self: PlayerState;
  allPlayers: PlayerState[];
  simTimeMs: number;
};

/**
 * A BT node that evaluates and returns a result
 */
export type BTNode = {
  /** Evaluate the node and return a result */
  tick: (ctx: BTContext) => BTResult;
  /** Optional name for tracing */
  name?: string;
  /** Optional short description for tooltips */
  description?: string;
};

// ============================================================================
// Config types for object-based node creation
// ============================================================================

/** Config for creating a Condition node with description */
export type ConditionConfig = {
  name?: string;
  description?: string;
  check: (ctx: BTContext) => boolean;
};

/** Config for creating an Action node with description */
export type ActionConfig = {
  name?: string;
  description?: string;
  fn: (ctx: BTContext) => { status: BTStatus; intents?: Intent[]; note?: string };
};

/** Config for creating a Selector or Sequence node with description */
export type CompositeConfig = {
  name?: string;
  description?: string;
  children: BTNode[];
};

/**
 * Create a trace object for a node
 */
const createTrace = (
  nodeType: BTNodeType,
  status: BTStatus,
  name?: string,
  note?: string,
  children?: BTNodeTrace[],
  description?: string
): BTNodeTrace => ({
  nodeType,
  nodeName: name,
  description,
  status,
  note,
  children,
});

/**
 * Selector node - returns SUCCESS on first child success, FAILURE if all fail
 * Supports both legacy (children, name) and new config object syntax
 */
export function Selector(config: CompositeConfig): BTNode;
export function Selector(children: BTNode[], name?: string): BTNode;
export function Selector(
  childrenOrConfig: BTNode[] | CompositeConfig,
  name?: string
): BTNode {
  // Handle object config
  if (!Array.isArray(childrenOrConfig)) {
    const config = childrenOrConfig;
    return {
      name: config.name,
      description: config.description,
      tick: (ctx) => {
        const childTraces: BTNodeTrace[] = [];
        const allIntents: Intent[] = [];

        for (const child of config.children) {
          const result = child.tick(ctx);
          childTraces.push(result.trace);
          allIntents.push(...result.intents);

          if (result.status === "SUCCESS" || result.status === "RUNNING") {
            return {
              status: result.status,
              intents: allIntents,
              trace: createTrace(
                "Selector",
                result.status,
                config.name,
                undefined,
                childTraces,
                config.description
              ),
            };
          }
        }

        return {
          status: "FAILURE",
          intents: allIntents,
          trace: createTrace(
            "Selector",
            "FAILURE",
            config.name,
            "All children failed",
            childTraces,
            config.description
          ),
        };
      },
    };
  }

  // Legacy signature
  return {
    name,
    tick: (ctx) => {
      const childTraces: BTNodeTrace[] = [];
      const allIntents: Intent[] = [];

      for (const child of childrenOrConfig) {
        const result = child.tick(ctx);
        childTraces.push(result.trace);
        allIntents.push(...result.intents);

        if (result.status === "SUCCESS" || result.status === "RUNNING") {
          return {
            status: result.status,
            intents: allIntents,
            trace: createTrace("Selector", result.status, name, undefined, childTraces),
          };
        }
      }

      return {
        status: "FAILURE",
        intents: allIntents,
        trace: createTrace("Selector", "FAILURE", name, "All children failed", childTraces),
      };
    },
  };
}

/**
 * Sequence node - returns FAILURE on first child failure, SUCCESS if all succeed
 * Supports both legacy (children, name) and new config object syntax
 */
export function Sequence(config: CompositeConfig): BTNode;
export function Sequence(children: BTNode[], name?: string): BTNode;
export function Sequence(
  childrenOrConfig: BTNode[] | CompositeConfig,
  name?: string
): BTNode {
  // Handle object config
  if (!Array.isArray(childrenOrConfig)) {
    const config = childrenOrConfig;
    return {
      name: config.name,
      description: config.description,
      tick: (ctx) => {
        const childTraces: BTNodeTrace[] = [];
        const allIntents: Intent[] = [];

        for (const child of config.children) {
          const result = child.tick(ctx);
          childTraces.push(result.trace);
          allIntents.push(...result.intents);

          if (result.status === "FAILURE" || result.status === "RUNNING") {
            return {
              status: result.status,
              intents: allIntents,
              trace: createTrace(
                "Sequence",
                result.status,
                config.name,
                undefined,
                childTraces,
                config.description
              ),
            };
          }
        }

        return {
          status: "SUCCESS",
          intents: allIntents,
          trace: createTrace(
            "Sequence",
            "SUCCESS",
            config.name,
            undefined,
            childTraces,
            config.description
          ),
        };
      },
    };
  }

  // Legacy signature
  return {
    name,
    tick: (ctx) => {
      const childTraces: BTNodeTrace[] = [];
      const allIntents: Intent[] = [];

      for (const child of childrenOrConfig) {
        const result = child.tick(ctx);
        childTraces.push(result.trace);
        allIntents.push(...result.intents);

        if (result.status === "FAILURE" || result.status === "RUNNING") {
          return {
            status: result.status,
            intents: allIntents,
            trace: createTrace("Sequence", result.status, name, undefined, childTraces),
          };
        }
      }

      return {
        status: "SUCCESS",
        intents: allIntents,
        trace: createTrace("Sequence", "SUCCESS", name, undefined, childTraces),
      };
    },
  };
}

/**
 * Condition node - evaluates a predicate and returns SUCCESS or FAILURE
 * Supports both legacy (predicate, name) and new config object syntax
 */
export function Condition(config: ConditionConfig): BTNode;
export function Condition(
  predicate: (ctx: BTContext) => boolean,
  name?: string
): BTNode;
export function Condition(
  predicateOrConfig: ((ctx: BTContext) => boolean) | ConditionConfig,
  name?: string
): BTNode {
  // Handle object config
  if (typeof predicateOrConfig === "object") {
    const config = predicateOrConfig;
    return {
      name: config.name,
      description: config.description,
      tick: (ctx) => {
        const result = config.check(ctx);
        const status: BTStatus = result ? "SUCCESS" : "FAILURE";
        return {
          status,
          intents: [],
          trace: createTrace(
            "Condition",
            status,
            config.name,
            result ? "Condition met" : "Condition not met",
            undefined,
            config.description
          ),
        };
      },
    };
  }

  // Legacy signature
  return {
    name,
    tick: (ctx) => {
      const result = predicateOrConfig(ctx);
      const status: BTStatus = result ? "SUCCESS" : "FAILURE";
      return {
        status,
        intents: [],
        trace: createTrace(
          "Condition",
          status,
          name,
          result ? "Condition met" : "Condition not met"
        ),
      };
    },
  };
}

/**
 * Action node - executes an action and returns intents
 * Supports both legacy (fn, name) and new config object syntax
 */
export function Action(config: ActionConfig): BTNode;
export function Action(
  fn: (ctx: BTContext) => { status: BTStatus; intents?: Intent[]; note?: string },
  name?: string
): BTNode;
export function Action(
  fnOrConfig:
    | ((ctx: BTContext) => { status: BTStatus; intents?: Intent[]; note?: string })
    | ActionConfig,
  name?: string
): BTNode {
  // Handle object config
  if (typeof fnOrConfig === "object") {
    const config = fnOrConfig;
    return {
      name: config.name,
      description: config.description,
      tick: (ctx) => {
        const result = config.fn(ctx);
        return {
          status: result.status,
          intents: result.intents ?? [],
          trace: createTrace(
            "Action",
            result.status,
            config.name,
            result.note,
            undefined,
            config.description
          ),
        };
      },
    };
  }

  // Legacy signature
  return {
    name,
    tick: (ctx) => {
      const result = fnOrConfig(ctx);
      return {
        status: result.status,
        intents: result.intents ?? [],
        trace: createTrace("Action", result.status, name, result.note),
      };
    },
  };
}

/**
 * RequestGoal node - creates an intent to request a goal
 */
export const RequestGoal = (
  goal: RequestedGoal,
  reason?: string,
  name?: string
): BTNode =>
  Action(
    (ctx) => {
      const intent = createGoalIntent(
        ctx.self.id,
        goal.type,
        reason ?? `Requesting goal: ${goal.type}`,
        "AI",
        1.0
      );
      return {
        status: "SUCCESS",
        intents: [intent],
        note: `Requested goal: ${goal.type}`,
      };
    },
    name ?? `RequestGoal(${goal.type})`
  );

/**
 * YieldToMovementSystem - placeholder that indicates movement system should handle motion
 */
export const YieldToMovementSystem = (): BTNode =>
  Action({
    name: "YieldToMovementSystem",
    description: "Hand off to the movement system to execute the goal",
    fn: () => ({
      status: "SUCCESS",
      note: "Yielding to movement system",
    }),
  });

/**
 * Named decorator - wraps a node with a name for tracing
 */
export const Named = (node: BTNode, name: string): BTNode => ({
  name,
  tick: (ctx) => {
    const result = node.tick(ctx);
    return {
      ...result,
      trace: {
        ...result.trace,
        nodeName: name,
      },
    };
  },
});

/**
 * Inverter decorator - inverts SUCCESS to FAILURE and vice versa
 */
export const Inverter = (child: BTNode, name?: string): BTNode => ({
  name,
  tick: (ctx) => {
    const result = child.tick(ctx);
    const invertedStatus: BTStatus =
      result.status === "SUCCESS"
        ? "FAILURE"
        : result.status === "FAILURE"
        ? "SUCCESS"
        : "RUNNING";
    return {
      status: invertedStatus,
      intents: result.intents,
      trace: createTrace("Decorator", invertedStatus, name ?? "Inverter", undefined, [
        result.trace,
      ]),
    };
  },
});

/**
 * Succeeder decorator - always returns SUCCESS
 */
export const Succeeder = (child: BTNode, name?: string): BTNode => ({
  name,
  tick: (ctx) => {
    const result = child.tick(ctx);
    return {
      status: "SUCCESS",
      intents: result.intents,
      trace: createTrace("Decorator", "SUCCESS", name ?? "Succeeder", undefined, [
        result.trace,
      ]),
    };
  },
});

// ============================================================================
// Legacy compatibility layer
// These functions support gradual migration from the old callback-based API
// ============================================================================

/**
 * Legacy BTContext type with callbacks (for gradual migration)
 * @deprecated Use BTContext instead
 */
export type LegacyBTContext = {
  blackboard: Blackboard;
  self: PlayerState;
  allPlayers: PlayerState[];
  /** @deprecated Use intents instead */
  requestGoal: (goal: RequestedGoal) => void;
  /** @deprecated Use traces instead */
  publishThought: (content: string, meta?: Partial<ThoughtMessage["meta"]>) => void;
  simTimeMs: number;
};

/**
 * Legacy BTNode type (for gradual migration)
 * @deprecated Use BTNode instead
 */
export type LegacyBTNode = {
  tick: (ctx: LegacyBTContext) => BTStatus;
};

/**
 * Adapt a legacy BT node to the new pure interface
 */
export const adaptLegacyNode = (
  legacyNode: LegacyBTNode,
  name?: string
): BTNode => ({
  name,
  tick: (ctx) => {
    const collectedIntents: Intent[] = [];

    const legacyCtx: LegacyBTContext = {
      blackboard: ctx.blackboard,
      self: ctx.self,
      allPlayers: ctx.allPlayers,
      simTimeMs: ctx.simTimeMs,
      requestGoal: (goal) => {
        collectedIntents.push(
          createGoalIntent(
            ctx.self.id,
            goal.type,
            `Legacy goal request: ${goal.type}`,
            "AI"
          )
        );
      },
      publishThought: () => {
        // Thoughts are now captured via traces, this is a no-op for compatibility
      },
    };

    const status = legacyNode.tick(legacyCtx);

    return {
      status,
      intents: collectedIntents,
      trace: createTrace("Action", status, name ?? "LegacyNode"),
    };
  },
});

/**
 * Convert a new BTNode to legacy format (for backward compatibility during migration)
 */
export const toLegacyNode = (node: BTNode): LegacyBTNode => ({
  tick: (legacyCtx) => {
    const ctx: BTContext = {
      blackboard: legacyCtx.blackboard,
      self: legacyCtx.self,
      allPlayers: legacyCtx.allPlayers,
      simTimeMs: legacyCtx.simTimeMs,
    };

    const result = node.tick(ctx);

    // Apply collected intents via legacy callback
    for (const intent of result.intents) {
      if (intent.action.type === "REQUEST_GOAL") {
        legacyCtx.requestGoal({ type: intent.action.goal });
      }
    }

    return result.status;
  },
});
